#! /usr/bin/env python

"""
Eye-on-hand calibration. Park and Martin Method.
Source: http://www.cs.jhu.edu/~sleonard/lecture03.pdf
AX=XB
@author: Hongtao Wu
Nov 13, 2019
"""

import numpy as np

def axxb(robotPose, markerPose):
  """
  AX=XB solver.
  
  Args:
  - robotPose (list of 4x4 numpy array): poses (homogenous transformation) of the robot end-effector in the robot base frame.
  - markerPose (list of 4x4 numpy array): poses (homogenous transformation) of the marker in the camera frame.

  Return:
  - cam2ee (4x4 numpy array): poses of the camera in the robot end-effector frame.
  """

  assert len(robotPose) == len(markerPose), 'robot poses and marker poses are not of the same length!'

  n = len(robotPose)
  print "Total Pose: %i" % n
  A = np.zeros((4, 4, n-1))
  B = np.zeros((4, 4, n-1))
  alpha = np.zeros((3, n-1))
  beta = np.zeros((3, n-1))

  M = np.zeros((3, 3))

  for i in range(n-1):
    A[:, :, i] = np.matmul(pose_inv(robotPose[i+1]), robotPose[i])
    B[:, :, i] = np.matmul(markerPose[i+1], pose_inv(markerPose[i]))
    alpha[:, i] = get_mat_log(A[:3, :3, i])
    beta[:, i] = get_mat_log(B[:3, :3, i])
    M += np.outer(beta[:, i], alpha[:, i])

  # Get the rotation matrix
  mtm = np.matmul(M.T, M)
  u_mtm, s_mtm, vh_mtm = np.linalg.svd(mtm)
  R = np.matmul(np.matmul(np.matmul(u_mtm, np.diag(np.power(s_mtm, -0.5))), vh_mtm), M.T)

  # Get the tranlation vector
  I_Ra_Left = np.zeros((3*(n-1), 3))
  ta_Rtb_Right = np.zeros((3 * (n-1), 1))
  for i in range(n-1):
    I_Ra_Left[(3*i):(3*(i+1)), :] = np.eye(3) - A[:3, :3, i]
    ta_Rtb_Right[(3*i):(3*(i+1)), :] = np.reshape(A[:3, 3, i] - np.dot(R, B[:3, 3, i]), (3, 1))
  t = np.linalg.lstsq(I_Ra_Left, ta_Rtb_Right, rcond=None)[0]
  
  cam2ee = np.c_[R, t]
  cam2ee = np.r_[cam2ee, [[0, 0, 0, 1]]]

  print "Calibration Result:\n", cam2ee
  
  return cam2ee


def pose_inv(pose):
    """
    Inverse of a homogenenous transformation.

    Args:
    - pose (4x4 numpy array)

    Return:
    - inv_pose (4x4 numpy array)
    """
    R = pose[:3, :3]
    t = pose[:3, 3]

    inv_R = R.T
    inv_t = - np.dot(inv_R, t)

    inv_pose = np.c_[inv_R, np.transpose(inv_t)]
    inv_pose = np.r_[inv_pose, [[0, 0, 0, 1]]]

    return inv_pose


def get_mat_log(R):
  """
  Get the log(R) of the rotation matrix R.
  
  Args:
  - R (3x3 numpy array): rotation matrix

  Returns:
  - w (3, numpy array): log(R)
  """
  theta = np.arccos((np.trace(R) - 1) / 2)
  w_hat = (R - R.T) * theta / (2 * np.sin(theta))  # Skew symmetric matrix
  w = np.array([w_hat[2, 1], w_hat[0, 2], w_hat[1, 0]])  # [w1, w2, w3]

  return w


# # Test
# if __name__ == "__main__":
#   robotPose = [np.array([[ 0.98422333,  0.16262786, -0.06968943, -0.02934809],
#               [-0.15297446,  0.98007911,  0.12666392, -0.16365885],
#               [ 0.08890024, -0.11400488,  0.98949464,  0.01440832],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.99502285, -0.08083996, -0.05826176,  0.01112392],
#               [ 0.08192331,  0.9965029 ,  0.01644831,  0.02675394],
#               [ 0.05672833, -0.02113945,  0.99816583, -0.00252316],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.99576407, -0.03199916, -0.08619723,  0.08603976],
#               [ 0.04334773,  0.99014246,  0.13318741, -0.09871659],
#               [ 0.08108565, -0.13635969,  0.98733538,  0.0191289 ],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98820026, -0.03012889,  0.15017485, -0.09347216],
#               [ 0.01443606,  0.99441889,  0.10451162, -0.21179011],
#               [-0.15248553, -0.10111047,  0.98311995, -0.00642004],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.99020378, -0.01541953,  0.13877579, -0.06938125],
#               [ 0.01869679,  0.99957552, -0.02234289,  0.02458537],
#               [-0.13837236,  0.02471868,  0.99007175, -0.00243526],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98724063, -0.08224871, -0.13634912,  0.08634056],
#               [ 0.03157505,  0.94038584, -0.33864065,  0.40669902],
#               [ 0.15607353,  0.33001458,  0.93098412,  0.08750785],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98997207,  0.11655479, -0.07981403,  0.04288633],
#               [-0.10914875,  0.98979565,  0.09160305, -0.10766851],
#               [ 0.08967635, -0.08197286,  0.99259186,  0.02405363],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.97598531,  0.09091237, -0.1979586 ,  0.04449141],
#               [-0.12014852,  0.98268243, -0.14106584,  0.14838502],
#               [ 0.18170581,  0.16146262,  0.97000661, -0.00423883],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.99142938, -0.09189914,  0.09285647, -0.10043   ],
#               [ 0.10224582,  0.98824922, -0.11361898,  0.15536732],
#               [-0.08132384,  0.12213938,  0.98917562, -0.00941572],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98419643, -0.16249852,  0.07036778,  0.05190255],
#               [ 0.15850597,  0.98559007,  0.05905994,  0.03366005],
#               [-0.07895094, -0.04697287,  0.99577121,  0.05104508],
#               [ 0.        ,  0.        ,  0.        ,  1.        ]])]
#   markerPose = [np.array([[ 0.99104279, -0.08719624, -0.1011484 ,  0.11735632],
#                 [ 0.06922857,  0.98314148, -0.16923423, -0.00668728],
#                 [ 0.11419978,  0.16071601,  0.98037175, -0.06943206],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.99823651, -0.05517647, -0.02189573,  0.07879085],
#                 [ 0.05675719,  0.99520042,  0.07971669, -0.07284153],
#                 [ 0.01739215, -0.08081885,  0.99657705,  0.01753204],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98674854, -0.07838326, -0.14206825,  0.10158963],
#                 [ 0.08532049,  0.99540763,  0.04340573, -0.03321687],
#                 [ 0.13801353, -0.05495188,  0.98890473, -0.0081341 ],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98069404,  0.15779515, -0.11549842, -0.07637637],
#                 [-0.15152578,  0.98655443,  0.06123959,  0.00856854],
#                 [ 0.12360879, -0.04255632,  0.99141809,  0.09925185],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98931543,  0.14163455,  0.0345635 , -0.10569034],
#                 [-0.14241277,  0.98958054,  0.02118858,  0.07584251],
#                 [-0.03120233, -0.02588447,  0.99917787,  0.01817108],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.93130077, -0.16110832,  0.32668484, -0.00723478],
#                 [ 0.13573789,  0.98576741,  0.09918587, -0.06893468],
#                 [-0.33801494, -0.04802837,  0.93991445,  0.0367195 ],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.99324797, -0.08681646, -0.07695044,  0.07008854],
#                 [ 0.07675025,  0.98914544, -0.12530245,  0.02024034],
#                 [ 0.08699349,  0.11855044,  0.98912988, -0.06781091],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.9698421 , -0.18246889,  0.16159024,  0.12266894],
#                 [ 0.19759418,  0.9767672 , -0.08296003, -0.05994803],
#                 [-0.14269842,  0.11238743,  0.98336475, -0.02801189],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.98983859,  0.08260164,  0.1157434 , -0.04855098],
#                 [-0.09332056,  0.99151722,  0.09047031, -0.01202651],
#                 [-0.10728858, -0.10035224,  0.98915044,  0.04751161],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]]), np.array([[ 0.99564657,  0.07970944, -0.04831471, -0.08234167],
#                 [-0.0701026 ,  0.98199047,  0.17544328,  0.02444611],
#                 [ 0.06142907, -0.17129251,  0.98330328,  0.00289196],
#                 [ 0.        ,  0.        ,  0.        ,  1.        ]])]

#   cam2ee = axxb(robotPose, markerPose)